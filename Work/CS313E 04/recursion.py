"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my honor, William Hao, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: wah938
"""

def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """

    if start == len(nums): # base case - reached end of array
        return target == 0

    include_start = group_sum(start+1, nums, target - nums[start]) # start was added to the sum
    exclude_start = group_sum(start+1, nums, target) # start was not added to the sum

    return (include_start or exclude_start)


def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """

    if start == len(nums):
        return target == 0

    is_6 = nums[start] == 6
    if is_6:
        return group_sum_6(start+1, nums, target - nums[start]) # mandatory add the 6 to the sum
    else: # work like a normal group sum
        include_start = group_sum_6(start+1, nums, target - nums[start])
        exclude_start = group_sum_6(start+1, nums, target)
        return (include_start or exclude_start)


def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """

    if start >= len(nums): # changing from == to >= now, since start+2 could go out of bounds
        return target == 0

    include_start = group_no_adj(start+2, nums, target-nums[start]) # +2 instead of +1, skip adj
    exclude_start = group_no_adj(start+1, nums, target)

    return (include_start or exclude_start)


def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 if 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """

    if start >= len(nums):
        return target == 0

    is_multiple_5 = (nums[start]%5) == 0

    if is_multiple_5:
        is_1 = (nums[start+1])==1 # check if element right after == 1
        if is_1:
            return group_sum_5(start+2, nums, target-nums[start]) # skip it, +2
        if not is_1:
            return group_sum_5(start+1, nums, target-nums[start]) # proceed as normal
    else: # work like a normal group sum
        include_start = group_sum_5(start+1, nums, target - nums[start])
        exclude_start = group_sum_5(start+1, nums, target)
        return (include_start or exclude_start)


def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """

    if start >= len(nums):
        return target == 0

    # use a while loop to find the sum of a clump (if it is a clump)
    current_num = nums[start]
    sum_clump = 0 + nums[start]
    index_to_check = start+1 # if no clump, this while loop will not run at all, so index = start+1
    while index_to_check<len(nums) and nums[index_to_check] == current_num:
        sum_clump += nums[index_to_check]
        index_to_check += 1

    # normal recursion
    include_clump = group_sum_clump(index_to_check, nums, target-sum_clump) # using index_to_check
    exclude_clump = group_sum_clump(index_to_check, nums, target)

    return (include_clump or exclude_clump)


def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    total = sum(nums)
    if total % 2 == 1: # a base case - cannot split into 2 if odd sum
        return False

    def helper(start, current_sum):
        # base case - reached end of list; check if the current sum is half the total
        if start == len(nums):
            return current_sum == (total // 2)

        # recursive cases: include or exclude the current number
        include = helper(start+1, current_sum+nums[start])
        exclude = helper(start+1, current_sum)

        return (include or exclude)

    return helper(0, 0)


def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """

    def helper(start, sum_odd, sum_10):
        # base case - reached end of list, check the conditions
        if start == len(nums):
            return (sum_odd % 2 == 1) and (sum_10 % 10 == 0)

        # recursive cases: place the current number either in sum_odd or sum_10. No exclude case
        include_odd = helper(start+1, sum_odd + nums[start], sum_10)
        include_10 = helper(start+1, sum_odd, sum_10 + nums[start])

        return (include_odd or include_10)

    return helper(0, 0, 0)


def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """

    def helper(start, sum_5, sum_3):
        # base case
        if start == len(nums):
            return sum_5 == sum_3

        # recursive cases
        if nums[start] % 5 == 0:
            return helper(start+1, sum_5 + nums[start], sum_3)
        elif nums[start] % 3 == 0:
            return helper(start+1, sum_5, sum_3 + nums[start])
        else:
            include_5 = helper(start+1, sum_5 + nums[start], sum_3)
            include_3 = helper(start+1, sum_5, sum_3 + nums[start])
            return (include_5 or include_3)

    return helper(0, 0, 0)
